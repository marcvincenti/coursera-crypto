#!/usr/bin/env python
#coding: utf-8

import gmpy2

""" RSA
Your goal in this project is to break RSA when the public modulus N is generated
incorrectly. This should serve as yet another reminder not to implement crypto
primitives yourself.

Normally, the primes that comprise an RSA modulus are generated independently of
one another. But suppose a developer decides to generate the first prime p by
choosing a random number R and scanning for a prime close by. The second prime q
is generated by scanning for some other random prime also close to R.

We show that the resulting RSA modulus N = pq can be easily factored.

Let A be the arithmetic average of the two primes, that is A = (p+q)/2
â€‹Since p and q are odd, we know that (p+q) is even and therefore A is an integer.

But since A is an integer, rounding sqrt(N) up to the closest integer reveals
the value of A. In code, A = ceil(sqrt(N)) where "ceil" is the ceiling function.
The numbers are ordered as follows: p < sqrt(N) < A=(p+q)/2 < q

Since A is the exact mid-point between p and q there is an integer x such that
p = A - x and q = A + x.

But then N = p * q = (A-x) (A+x) = A^2 - x^2 and therefore x = sqrt(A^2 - N)

Now, given x and A you can find the factors p and q of N since p = A - x
and q = A + x. You have now factored N !
"""

N_1 = 179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581
N_2 = 648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877

def factor(_n):
    n = gmpy2.mpz(_n)
    base_A = gmpy2.isqrt(n)
    if gmpy2.is_even(base_A):
        base_A = gmpy2.add(base_A, 1)
    for i in range(0, 2**20, 2):
        try:
            A = gmpy2.add(base_A, i)
            x = gmpy2.isqrt(gmpy2.sub(gmpy2.mul(A, A), n))
            p = gmpy2.sub(A, x)
            q = gmpy2.add(A, x)
            if n == gmpy2.mul(p, q):
                return (p, q)
        except:
            pass
    return (None, None)

print " 1 - " + str(factor(N_1)[0])
print " 2 - " + str(factor(N_2)[0])

N_3 = 720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929

def factor_3p_2q(_n):
    n = gmpy2.mpz(_n)
    nx6 = gmpy2.mul(n, 6)
    base_A = gmpy2.isqrt(nx6)
    if gmpy2.is_even(base_A):
        base_A = gmpy2.add(base_A, 1)
    for i in range(0, 2**20, 2):
        A = gmpy2.add(base_A, i)
        x = gmpy2.isqrt(gmpy2.sub(gmpy2.sub(gmpy2.mul(A, A), nx6), A))
        p = gmpy2.t_div(gmpy2.sub(A, x), 3)
        q = gmpy2.t_div(gmpy2.add(A, x), 2)
        if n == gmpy2.mul(p, q):
            return (p, q)
    return (None, None)

print " 3 - " + str(factor_3p_2q(N_3)[0])

CIPHER = 22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540
N = 179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581
e = 65537

(p, q) = factor(N_1)
phi_N = N + 1 - (p + q)
d = gmpy2.invert(e, phi_N)
padded_m = hex(gmpy2.powmod(CIPHER, d, N))
m = padded_m[padded_m.find('00')+2:]
print " 4 - " + "".join([chr(l) for l in bytearray.fromhex(m)])
